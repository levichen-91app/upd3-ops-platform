# 稽核日誌功能研究報告

**日期**: 2025-10-06  
**功能**: 系統稽核日誌  

## 技術選型研究

### 1. NestJS Interceptor vs Middleware 選擇

**決策**: 使用 NestJS Interceptor  
**理由**: 
- Interceptor 可以在方法執行前後進行處理，適合記錄請求和回應
- 可以存取 ExecutionContext，獲得更豐富的元資料
- 支援路由層級的精確控制，只攔截特定端點
- 能夠處理異常情況，確保失敗的操作也被記錄

**替代方案考慮**: 
- Middleware: 位於請求管道較早階段，無法獲得回應狀態碼
- Guard: 主要用於認證授權，不適合日誌記錄

### 2. 檔案儲存格式選擇

**決策**: JSON Lines (.jsonl)  
**理由**:
- 每行一個 JSON 物件，便於流式處理和解析
- 檔案損壞時只影響單行，其他記錄仍可讀取
- 支援 append 操作，無需讀取整個檔案
- 便於日誌分析工具處理 (grep, awk, 各種日誌分析器)

**替代方案考慮**:
- 純 JSON 陣列: 需要重寫整個檔案，效能差
- CSV: 結構化程度不足，無法處理巢狀物件
- Binary 格式: 不利於除錯和手動檢查

### 3. 敏感資料遮罩策略

**決策**: 遞迴深度優先搜尋，基於欄位名稱模式匹配  
**理由**:
- 支援巢狀物件的完整遍歷
- 基於欄位名稱 (password, token, secret, key) 的模式匹配簡單可靠
- 保持原始資料結構，只替換值內容
- 效能良好，O(n) 複雜度

**實作方式**:
```typescript
// 模式匹配: 不區分大小寫，支援底線和駝峰命名
const SENSITIVE_PATTERNS = [
  /password/i, /token/i, /secret/i, /key/i,
  /passwd/i, /pwd/i, /auth/i
];

function maskSensitiveData(obj: any): any {
  // 遞迴處理物件和陣列
  // 匹配模式的欄位值替換為 "***"
}
```

**替代方案考慮**:
- 基於值內容檢測: 複雜度高，誤判率高
- 白名單模式: 維護成本高，容易遺漏

### 4. 檔案 I/O 策略

**決策**: 同步檔案寫入 (fs.appendFileSync)  
**理由**:
- 符合澄清結果的低容量需求 (≤1 ops/sec)
- 確保資料一致性，避免非同步寫入的時序問題
- 簡化錯誤處理，寫入失敗立即可知
- 無需維護寫入佇列或緩衝區

**容錯處理**:
- 寫入失敗時立即拋出異常，觸發 HTTP 503 回應
- 自動建立目錄結構 (fs.mkdirSync recursive)
- 檔案權限檢查和錯誤提示

**替代方案考慮**:
- 非同步寫入: 增加複雜度，低容量場景下無明顯好處
- 記憶體緩衝: 增加資料遺失風險

### 5. 檔案清理機制

**決策**: 排程任務 (node-cron) + 啟動時檢查  
**理由**:
- node-cron 提供可靠的排程機制
- 每日檢查清理過期檔案 (>30天)
- 應用啟動時執行一次清理，處理停機期間的積累

**實作方式**:
```typescript
// 每日凌晨 2:00 執行清理
cron.schedule('0 2 * * *', () => {
  this.cleanupExpiredFiles();
});

// 啟動時立即檢查
onModuleInit() {
  this.cleanupExpiredFiles();
}
```

**替代方案考慮**:
- OS 層級 crontab: 需要額外部署配置
- 手動清理: 運維負擔重，容易忘記

### 6. Request ID 整合

**決策**: 使用現有的 RequestIdMiddleware 機制  
**理由**:
- 符合憲章要求的統一 Request ID 策略
- 現有機制已處理 ID 生成、驗證、傳遞
- 確保稽核日誌與其他系統日誌的 ID 一致性

**整合方式**:
```typescript
// 在 Interceptor 中獲取 Request ID
const request = context.switchToHttp().getRequest();
const requestId = request.requestId; // 由 RequestIdMiddleware 注入
```

### 7. 查詢 API 設計

**決策**: RESTful API + 分頁查詢  
**理由**:
- 符合專案既有的 API 設計風格
- 標準化的查詢參數便於前端整合
- 分頁機制控制回應大小，避免記憶體問題

**端點設計**:
```
GET /api/v1/audit-logs?operatorFilter={operator}&page={page}&action={action}&startDate={date}&endDate={date}&limit={n}&offset={n}
```

## 效能評估

### 檔案 I/O 效能
- 單次寫入延遲: ~1-5ms (SSD)
- 同步寫入對 API 回應時間影響: +1-5ms
- 在 ≤1 ops/sec 負載下影響可忽略

### 查詢效能
- 7天資料預估量: ~600 筆記錄 (≤1 ops/sec)
- 檔案讀取時間: ~10-50ms
- JSON 解析時間: ~1-5ms
- 總查詢時間: <100ms (符合一般 API 回應標準)

### 儲存空間
- 單筆記錄大小: ~1-2KB (含完整請求資料)
- 日檔案大小: ~100-200KB/天
- 30天保留: ~3-6MB 總容量

## 風險評估

### 技術風險
1. **檔案系統故障**: 透過異常處理和 HTTP 503 回應機制
2. **磁碟空間不足**: 自動清理機制 + 監控告警
3. **高併發寫入**: 目前需求 ≤1 ops/sec，風險極低

### 資料風險
1. **敏感資料洩露**: 多層遮罩機制 + 模式匹配驗證
2. **日誌完整性**: 同步寫入 + 錯誤處理確保一致性
3. **資料遺失**: 檔案系統本身的可靠性，建議定期備份

### 維運風險
1. **日誌檔案堆積**: 自動清理機制防範
2. **查詢效能下降**: 7天範圍限制 + 分頁機制
3. **除錯困難**: JSON Lines 格式便於人工檢查

## 後續擴展建議

### 短期 (1-3個月)
- 增加稽核日誌的搜尋功能 (全文搜尋)
- 支援更多的查詢過濾條件
- 增加稽核統計和報表功能

### 中期 (3-6個月)
- 遷移至資料庫儲存 (利用現有的抽象介面)
- 增加即時稽核告警機制
- 支援稽核日誌的匯出功能

### 長期 (6個月以上)
- 整合專業日誌分析平台 (ELK Stack)
- 支援分散式稽核日誌收集
- 增加機器學習異常檢測功能

## 結論

研究結果顯示，基於 NestJS Interceptor + 檔案系統的設計方案完全滿足需求，技術風險可控，效能符合預期。設計遵循憲章原則，支援未來擴展。建議按計劃實作。